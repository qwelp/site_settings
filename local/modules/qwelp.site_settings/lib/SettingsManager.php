<?php/** * Класс для работы со СТРУКТУРОЙ настроек сайта из инфоблока. * Не работает со значениями. * * @package qwelp.site_settings */namespace Qwelp\SiteSettings;use Bitrix\Main\Application;use Bitrix\Main\Loader;use Bitrix\Main\Localization\Loc;use Bitrix\Main\SystemException;use Bitrix\Main\Web\Json;use CFile;use CIBlock;use CIBlockElement;use CIBlockSection;Loc::loadMessages(__FILE__);class SettingsManager{    private const IBLOCK_CODE = 'site_settings';    private const IBLOCK_TYPE = 'site_settings';    protected static ?int $iblockId = null;    /**     * @return int|null     * @throws SystemException     */    protected static function getIblockId(): ?int    {        if (self::$iblockId !== null) {            return self::$iblockId;        }        if (!Loader::includeModule('iblock')) {            throw new SystemException(Loc::getMessage('QWELP_SITE_SETTINGS_IBLOCK_MODULE_NOT_INSTALLED'));        }        $iblockRes = CIBlock::GetList(            [],            ['CODE' => self::IBLOCK_CODE, 'TYPE' => self::IBLOCK_TYPE, 'CHECK_PERMISSIONS' => 'N']        );        if ($iblock = $iblockRes->Fetch()) {            self::$iblockId = (int)$iblock['ID'];            return self::$iblockId;        }        return null;    }    /**     * Получает структуру настроек сайта в виде иерархии разделов и элементов.     *     * @param string|null $siteId ID сайта.     * @return array     * @throws SystemException     */    public static function getSettings(?string $siteId = null): array    {        $siteId = $siteId ?? Application::getInstance()->getContext()->getSite();        $iblockId = self::getIblockId();        if (!$iblockId) {            return ['sections' => []];        }        $allSections = [];        $sectionsRes = CIBlockSection::GetList(            ['SORT' => 'ASC', 'ID' => 'ASC'],            ['IBLOCK_ID' => $iblockId, 'ACTIVE' => 'Y'],            false,            [                'ID', 'IBLOCK_SECTION_ID', 'NAME', 'CODE', 'SORT', 'DEPTH_LEVEL', 'PICTURE',                'UF_ENABLE_DRAG_AND_DROP', 'UF_DETAIL_PROPERTY', 'UF_COMMON_PROPERTY',                'UF_COLLAPSED_BLOCK', 'UF_SECTION_TOOLTIP', 'UF_HIDDEN_ELEMENTS_TITLE', 'UF_HTML_BLOCK',                'UF_FULL_WIDTH',            ]        );        while ($sec = $sectionsRes->Fetch()) {            $allSections[(int)$sec['ID']] = [                'ID' => (int)$sec['ID'],                'PARENT_ID' => (int)$sec['IBLOCK_SECTION_ID'],                'id' => $sec['CODE'],                'title' => $sec['NAME'],                'PICTURE' => $sec['PICTURE'],                'SORT' => (int)$sec['SORT'],                'DEPTH' => (int)$sec['DEPTH_LEVEL'],                'UF_ENABLE_DRAG_AND_DROP' => (int)$sec['UF_ENABLE_DRAG_AND_DROP'],                'UF_DETAIL_PROPERTY' => (int)$sec['UF_DETAIL_PROPERTY'],                'UF_COMMON_PROPERTY' => (int)$sec['UF_COMMON_PROPERTY'],                'UF_COLLAPSED_BLOCK' => (int)$sec['UF_COLLAPSED_BLOCK'],                'UF_SECTION_TOOLTIP' => $sec['UF_SECTION_TOOLTIP'],                'UF_HTML_BLOCK' => $sec['UF_HTML_BLOCK'],                'UF_HIDDEN_ELEMENTS_TITLE' => $sec['UF_HIDDEN_ELEMENTS_TITLE'],                'UF_FULL_WIDTH' => (int)$sec['UF_FULL_WIDTH'],                'SUBSECTIONS' => [],                'settings' => [],            ];        }        foreach ($allSections as $secId => &$secData) {            if ($secData['PARENT_ID'] > 0 && isset($allSections[$secData['PARENT_ID']])) {                $allSections[$secData['PARENT_ID']]['SUBSECTIONS'][$secId] = &$secData;            }        }        unset($secData);        $elementsRes = CIBlockElement::GetList(            ['SORT' => 'ASC'],            ['IBLOCK_ID' => $iblockId, 'ACTIVE' => 'Y'],            false,            false,            ['ID', 'IBLOCK_ID', 'IBLOCK_SECTION_ID', 'NAME', 'CODE', 'PROPERTY_*']        );        while ($elem = $elementsRes->GetNextElement()) {            $fields = $elem->GetFields();            $props = $elem->GetProperties(false, ['EMPTY' => 'N']);            $secId = (int)$fields['IBLOCK_SECTION_ID'];            if (!isset($allSections[$secId])) {                continue;            }            $typeFromProp = strtolower(trim($props['TYPE']['VALUE'] ?? ''));            $raw = '';            if (isset($props['VALUES']['~VALUE'])) {                $value = $props['VALUES']['~VALUE'];                if (is_array($value) && isset($value['TEXT'])) {                    $raw = $value['TEXT'];                } elseif (is_string($value)) {                    $raw = $value;                }            }            $parsedOptions = [];            if ($raw) {                // Пытаемся декодировать JSON, даже если он "грязный"                if (preg_match('/([\[\{].*)$/s', $raw, $m)) {                    $opts = Json::decode($m[1]);                    if (json_last_error() === JSON_ERROR_NONE) {                        $parsedOptions = $opts;                    }                } else {                    // Если не JSON, возможно, это просто значение (для старых чекбоксов)                    $parsedOptions = ['value' => $raw];                }            }            // [FIXED] Более надежное определение типа            $type = '';            if ($typeFromProp !== '') {                $type = $typeFromProp;            } else {                $priorityOrder = ['color', 'radioImage', 'radio', 'select', 'pathFile', 'checkbox'];                foreach ($priorityOrder as $key) {                    if (isset($parsedOptions[$key])) {                        $type = $key;                        break;                    }                }                if ($type === '') $type = 'text';            }            $setting = [                'code' => $fields['CODE'],                'label' => $fields['NAME'],                'type' => $type,                'helpText' => $props['HELP_TEXT']['VALUE'] ?? '',                'helpImage' => !empty($props['HELP_IMAGE']['VALUE']) ? CFile::GetPath($props['HELP_IMAGE']['VALUE']) : null,                'headerTitle' => $props['HEADER_TITLE']['VALUE'] ?? '',                'percent' => $props['PERCENT']['VALUE'] ?? '',                'hiddenCheckbox' => $props['HIDDEN_CHECKBOX']['VALUE'] ?? '',                'detailProperty' => $props['DETAIL_PROPERTY']['VALUE'] ?? '',                'options' => [],                'value' => null, // Значение будет установлено позже из OptionsManager                'color_show_picker' => false, // [NEW] Значение по умолчанию            ];            // [NEW] Извлекаем состояние чекбокса для палитры            if (isset($parsedOptions['color_show_picker'])) {                $setting['color_show_picker'] = (bool)$parsedOptions['color_show_picker'];            }            if ($parsedOptions) {                // [FIXED] Корректно извлекаем опции для типа `color`                if ($type === 'color' && isset($parsedOptions['color'])) {                    // Если `color` - это массив опций (старый формат или новый без чекбокса)                    if (isset($parsedOptions['color'][0])) {                        $setting['options'] = $parsedOptions['color'];                    }                    // Если `color` - это объект с `items` (новый формат с чекбоксом)                    elseif (isset($parsedOptions['color']['items'])) {                        $setting['options'] = $parsedOptions['color']['items'];                    }                } elseif ($type !== 'color' && isset($parsedOptions[$type]) && is_array($parsedOptions[$type])) {                    $setting['options'] = $parsedOptions[$type];                }            }            if ($type === 'radioImage' && is_array($setting['options'])) {                foreach ($setting['options'] as &$opt) {                    if (!empty($opt['fileId'])) {                        $fileSrc = CFile::GetPath((int)$opt['fileId']);                        if ($fileSrc) $opt['pathFile'] = $fileSrc;                    }                }                unset($opt);            }            // Для обычного чекбокса без опций            if ($type === 'checkbox' && empty($setting['options'])) {                $setting['options'][] = [];            }            $allSections[$secId]['settings'][] = $setting;        }        $resultSections = array_filter($allSections, fn($sec) => $sec['PARENT_ID'] === 0);        usort($resultSections, fn($a, $b) => $a['SORT'] <=> $b['SORT']);        return ['sections' => array_values($resultSections)];    }}