<?phpnamespace Qwelp\SiteSettings\UserType;use Bitrix\Main\Application;use Bitrix\Main\Localization\Loc;/** * Класс пользовательского типа поля "Ключ-значение" для Bitrix D7. * Предназначен для сохранения и отображения пар ключ-значение в одном поле. * Сохраняет данные в формате JSON-строки. * * Примечание: Данный UserType предназначен для использования с множественным полем (MULTIPLE = Y), * где Bitrix сам управляет добавлением/удалением строк значений, а каждая строка содержит * пару "ключ-значение". */class KeyValueUserType{    /**     * Возвращает описание пользовательского типа поля.     * @return array     */    public static function GetUserTypeDescription()    {        // Загружаем языковые фразы для текущего файла        Loc::loadMessages(__FILE__);        return array(            "USER_TYPE_ID" => 'QWELP_SECTION_KEY_VALUE',            "CLASS_NAME" => __CLASS__,            // Используем языковую фразу для описания            "DESCRIPTION" => Loc::getMessage('QWELP_SITE_SETTINGS_USER_TYPE_KEY_VALUE_DESCRIPTION'),            "BASE_TYPE" => \CUserTypeManager::BASE_TYPE_STRING        );    }    /**     * Определяет тип колонки в базе данных для хранения значения.     * Используется 'text' для возможности хранения длинных JSON-строк.     * @return string     */    public static function GetDBColumnType()    {        global $DB;        switch (strtolower($DB->type)) {            case "mysql":                return "text";            case "oracle":                return "varchar2(4000 char)";            case "mssql":                return "varchar(4000)";        }        return "text";    }    /**     * Обрабатывает значение поля перед сохранением в базу данных.     * Преобразует массив ['key' => '...', 'value' => '...'] в JSON-строку.     * Метод должен быть статическим, чтобы Bitrix его вызывал.     *     * @param array $arUserField Массив с описанием пользовательского поля.     * @param mixed $value       Значение поля, пришедшее из формы (ожидается массив ['key' => '...', 'value' => '...']).     * @return string            JSON-строка или пустая строка для сохранения в БД.     */    public static function OnBeforeSave($arUserField, $value)    {        if (is_array($value) && (isset($value['key']) || isset($value['value']))) {            $filteredValue = [                'key' => trim((string)($value['key'] ?? '')),                'value' => trim((string)($value['value'] ?? ''))            ];            if (empty($filteredValue['key']) && empty($filteredValue['value'])) {                return '';            }            return json_encode($filteredValue, JSON_UNESCAPED_UNICODE);        }        return '';    }    /**     * Обрабатывает значение поля после извлечения из базы данных.     * Преобразует JSON-строку (или PHP-сериализованный массив из старых данных) обратно в PHP-массив     * ['key' => '...', 'value' => '...'].     * Метод должен быть статическим, чтобы Bitrix его вызывал.     *     * @param array $userfield Массив с описанием пользовательского поля.     * @param array $fetched   Массив с данными, извлеченными из БД, включая 'VALUE' и 'VALUE_RAW'.     * @return array           PHP-массив ['key' => '...', 'value' => '...'] или пустой массив.     */    public static function onAfterFetch($userfield, $fetched)    {        $value = $fetched["VALUE"];        $rawValue = $fetched["VALUE_RAW"];        if (is_string($value) && !empty($value)) {            $decoded = json_decode($value, true);            if (json_last_error() === JSON_ERROR_NONE && is_array($decoded)) {                return $decoded;            }        }        if (is_array($value) && (isset($value['key']) || isset($value['value']))) {            return $value;        }        if (is_string($rawValue) && !empty($rawValue)) {            $phpDecoded = @unserialize($rawValue);            if ($phpDecoded !== false && is_array($phpDecoded)) {                if (isset($phpDecoded['key']) || isset($phpDecoded['value'])) {                    return $phpDecoded;                }                $filtered = [];                foreach ($phpDecoded as $item) {                    if (is_array($item) && (isset($item['key']) || isset($item['value']))) {                        $filtered[] = $item;                    } else if (is_string($item) && $item === "Array") {                        $filtered[] = ['key' => '', 'value' => ''];                    }                }                if (!empty($filtered)) {                    return $filtered;                }            }        }        return [];    }    /**     * Генерирует HTML для отображения поля в форме редактирования.     * Поскольку поле множественное, этот метод вызывается для каждого значения.     * Метод должен быть статическим, чтобы Bitrix его вызывал.     *     * @param array $arUserField  Массив с описанием пользовательского поля.     * @param array $arHtmlControl Массив с элементами управления HTML, включая 'NAME' и 'VALUE'.     * @return string HTML-код поля.     */    public static function GetEditFormHTML($arUserField, $arHtmlControl)    {        // Загружаем языковые фразы для текущего файла        Loc::loadMessages(__FILE__);        $fieldName = $arHtmlControl["NAME"];        $currentValues = $arHtmlControl['VALUE'];        // Используем глобальную статическую переменную для отслеживания показа API блока        // Ключ основан на имени поля без индексов        static $globalApiBlockShown = [];        $baseFieldName = preg_replace('/\[\d+\]/', '', $arUserField['FIELD_NAME'] ?? 'unknown');        $apiCodeHtml = '';        // Показываем API блок только один раз для каждого типа поля И только для первого элемента [0]        if (!isset($globalApiBlockShown[$baseFieldName]) && strpos($fieldName, '[0]') !== false) {            $contextInfo = self::getContextInfo();            $apiCodeHtml = self::generateApiCodeBlock($contextInfo);            $globalApiBlockShown[$baseFieldName] = true;            // Добавляем JavaScript для копирования и стили для скрытия API блоков в новых строках            static $scriptAdded = false;            if (!$scriptAdded) {                echo '<style>                    /* Скрываем все API блоки кроме первого в каждой таблице */                    table[id*="UF_"] tr:not(:first-child) .qwelp-api-block-container {                        display: none !important;                    }                </style>';                echo '<script>                    function copyApiCode(button) {                        const codeElement = button.parentElement.querySelector("code");                        const text = codeElement.textContent;                        if (navigator.clipboard && window.isSecureContext) {                            navigator.clipboard.writeText(text).then(function() {                                button.textContent = "' . Loc::getMessage('QWELP_COPIED_MESSAGE') . '";                                setTimeout(function() {                                    button.textContent = "' . Loc::getMessage('QWELP_COPY_BUTTON') . '";                                }, 2000);                            });                        } else {                            // Fallback для старых браузеров                            const textArea = document.createElement("textarea");                            textArea.value = text;                            textArea.style.position = "fixed";                            textArea.style.left = "-999999px";                            textArea.style.top = "-999999px";                            document.body.appendChild(textArea);                            textArea.focus();                            textArea.select();                            document.execCommand("copy");                            textArea.remove();                            button.textContent = "' . Loc::getMessage('QWELP_COPIED_MESSAGE') . '";                            setTimeout(function() {                                button.textContent = "' . Loc::getMessage('QWELP_COPY_BUTTON') . '";                            }, 2000);                        }                    }                </script>';                $scriptAdded = true;            }        }        ob_start();        ?>        <?php if ($apiCodeHtml): ?>        <div class="qwelp-api-block-container">            <?= $apiCodeHtml ?>        </div>    <?php endif; ?>        <div class="qwelp-key-value-wrapper">            <div class="qwelp-key-value-item">                <?php                $key = '';                $value = '';                if (is_array($currentValues)) {                    $key = htmlspecialchars($currentValues['key'] ?? '');                    $value = htmlspecialchars($currentValues['value'] ?? '');                }                ?>                <input type="text" name="<?= htmlspecialchars($fieldName) ?>[key]" value="<?= $key ?>" placeholder="<?= Loc::getMessage('QWELP_SITE_SETTINGS_USER_TYPE_KEY_VALUE_PLACEHOLDER_KEY') ?>" class="adm-input" />                <input type="text" name="<?= htmlspecialchars($fieldName) ?>[value]" value="<?= $value ?>" placeholder="<?= Loc::getMessage('QWELP_SITE_SETTINGS_USER_TYPE_KEY_VALUE_PLACEHOLDER_VALUE') ?>" class="adm-input" />            </div>        </div>        <?php        $html = ob_get_clean();        return $html;    }    /**     * Генерирует HTML для поля редактирования свойства     */    public static function getPropertyFieldHtml(array $arProperty, array $value, array $strHTMLControlName): string    {        $fieldName = $strHTMLControlName['VALUE'];        $currentValues = $value['VALUE'] ?? '';        // Парсим текущее значение        $data = self::parseValue($currentValues);        // Используем статическую переменную для отслеживания показа API блока для каждого свойства        static $apiBlockShown = [];        $propertyId = $arProperty['ID'] ?? 'unknown';        $apiCodeHtml = '';        // Показываем API блок только один раз для каждого свойства        if (!isset($apiBlockShown[$propertyId])) {            $contextInfo = self::getContextInfo();            $apiCodeHtml = self::generateApiCodeBlock($contextInfo);            $apiBlockShown[$propertyId] = true;            // Добавляем JavaScript для копирования (только один раз)            static $scriptAdded = false;            if (!$scriptAdded) {                echo '<script>                    function copyApiCode(button) {                        const codeElement = button.parentElement.querySelector("code");                        const text = codeElement.textContent;                        if (navigator.clipboard && window.isSecureContext) {                            navigator.clipboard.writeText(text).then(function() {                                button.textContent = "' . Loc::getMessage('QWELP_COPIED_MESSAGE') . '";                                setTimeout(function() {                                    button.textContent = "' . Loc::getMessage('QWELP_COPY_BUTTON') . '";                                }, 2000);                            });                        } else {                            // Fallback для старых браузеров                            const textArea = document.createElement("textarea");                            textArea.value = text;                            textArea.style.position = "fixed";                            textArea.style.left = "-999999px";                            textArea.style.top = "-999999px";                            document.body.appendChild(textArea);                            textArea.focus();                            textArea.select();                            document.execCommand("copy");                            textArea.remove();                            button.textContent = "' . Loc::getMessage('QWELP_COPIED_MESSAGE') . '";                            setTimeout(function() {                                button.textContent = "' . Loc::getMessage('QWELP_COPY_BUTTON') . '";                            }, 2000);                        }                    }                </script>';                $scriptAdded = true;            }        }        ob_start();        ?>        <?= $apiCodeHtml ?>        <div class="qwelp-key-value-wrapper">            <div class="qwelp-key-value-item" style="display: flex; gap: 10px; align-items: center;">                <?php                $key = htmlspecialchars($data['key'] ?? '');                $val = htmlspecialchars($data['value'] ?? '');                ?>                <input type="text"                       name="<?= htmlspecialchars($fieldName) ?>[key]"                       value="<?= $key ?>"                       placeholder="<?= Loc::getMessage('QWELP_KEY_VALUE_PLACEHOLDER_KEY') ?>"                       class="adm-input"                       style="width: 200px;" />                <input type="text"                       name="<?= htmlspecialchars($fieldName) ?>[value]"                       value="<?= $val ?>"                       placeholder="<?= Loc::getMessage('QWELP_KEY_VALUE_PLACEHOLDER_VALUE') ?>"                       class="adm-input"                       style="width: 200px;" />            </div>        </div>        <?php        $html = ob_get_clean();        return $html;    }    /**     * Получает код раздела из контекста администрирования     *     * @return string|null Код раздела или null если не найден     */    private static function getSectionCodeFromContext(): ?string    {        // Используем методы Битрикса для получения GET параметров        $request = Application::getInstance()->getContext()->getRequest();        $sectionId = (int)$request->get('ID');        if ($sectionId > 0) {            // Загружаем модуль iblock если не загружен            if (!\Bitrix\Main\Loader::includeModule('iblock')) {                return null;            }            // Получаем раздел по ID            $section = \CIBlockSection::GetByID($sectionId)->GetNext();            if ($section && !empty($section['CODE'])) {                return $section['CODE'];            }        }        return null;    }    /**     * Получает код элемента из контекста администрирования     *     * @return string|null Код элемента или null если не найден     */    private static function getElementCodeFromContext(): ?string    {        // Используем методы Битрикса для получения GET параметров        $request = Application::getInstance()->getContext()->getRequest();        $elementId = (int)$request->get('ID');        if ($elementId > 0) {            // Загружаем модуль iblock если не загружен            if (!\Bitrix\Main\Loader::includeModule('iblock')) {                return null;            }            // Получаем элемент по ID            $element = \CIBlockElement::GetByID($elementId)->GetNext();            if ($element && !empty($element['CODE'])) {                return $element['CODE'];            }        }        return null;    }    /**     * Определяет контекст (элемент или раздел) и возвращает соответствующий код     *     * @return array|null Массив с типом контекста и кодом ['type' => 'element|section', 'code' => 'code']     */    private static function getContextInfo(): ?array    {        $request = Application::getInstance()->getContext()->getRequest();        // Проверяем URL или параметры для определения контекста        $uri = $request->getRequestUri();        // Если это страница редактирования раздела        if (strpos($uri, 'iblock_section_edit.php') !== false) {            $sectionCode = self::getSectionCodeFromContext();            if ($sectionCode) {                return ['type' => 'section', 'code' => $sectionCode];            }        }        // Если это страница редактирования элемента        if (strpos($uri, 'iblock_element_edit.php') !== false) {            $elementCode = self::getElementCodeFromContext();            if ($elementCode) {                return ['type' => 'element', 'code' => $elementCode];            }        }        return null;    }    /**     * Генерирует блок с API кодом для получения технических данных     *     * @param array|null $contextInfo Информация о контексте     * @return string HTML блок с API кодом     */    private static function generateApiCodeBlock(?array $contextInfo): string    {        // Если контекст не определен, не показываем блок с API        if (!$contextInfo) {            return '';        }        $type = $contextInfo['type'];        $code = $contextInfo['code'];        if ($type === 'section') {            $apiCode = "\\Qwelp\\SiteSettings\\OptionsManager::getSectionTechData('{$code}')";        } else {            $apiCode = "\\Qwelp\\SiteSettings\\OptionsManager::getTechData('{$code}')";        }        $html = '<div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px;">';        $html .= '<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px;">' . Loc::getMessage('QWELP_API_METHOD_TITLE') . '</h4>';        $html .= '<div style="display: flex; align-items: center; gap: 10px;">';        $html .= '<code style="background: #e9ecef; padding: 8px 12px; border-radius: 3px; font-family: monospace; flex: 1; user-select: all;">' . htmlspecialchars($apiCode) . '</code>';        $html .= '<button type="button" onclick="copyApiCode(this)" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 3px; cursor: pointer; font-size: 12px; white-space: nowrap;">' . Loc::getMessage('QWELP_COPY_BUTTON') . '</button>';        $html .= '</div>';        $html .= '</div>';        return $html;    }    /**     * Парсит значение в массив     */    private static function parseValue(string $value): array    {        if (empty($value)) {            return ['key' => '', 'value' => ''];        }        // Пытаемся распарсить как JSON        if (self::isJson($value)) {            $decoded = json_decode($value, true);            return is_array($decoded) ? $decoded : ['key' => '', 'value' => ''];        }        return ['key' => '', 'value' => ''];    }    /**     * Проверяет, является ли строка валидным JSON     */    private static function isJson(string $string): bool    {        json_decode($string);        return json_last_error() === JSON_ERROR_NONE;    }    /**     * Генерирует HTML для отображения в списке     */    public static function GetAdminListViewHTML($arUserField, $arHtmlControl)    {        $value = $arHtmlControl['VALUE'];        if (empty($value)) {            return '';        }        if (is_array($value)) {            $key = htmlspecialchars($value['key'] ?? '');            $val = htmlspecialchars($value['value'] ?? '');        } else {            $data = self::parseValue($value);            $key = htmlspecialchars($data['key'] ?? '');            $val = htmlspecialchars($data['value'] ?? '');        }        // Если оба поля пустые, не показываем ничего        if (trim($key) === '' && trim($val) === '') {            return '';        }        return '<strong>' . $key . ':</strong> ' . $val;    }}